<k番目の最短距離、及び最短路を求める関数>
戻り値(最短路とその距離を入れる構造体の配列)
引数(全ての座標、辺、座標の数、始点と終点の座標、求める最短路の数)

必要な変数：
求められた最短路の数を格納する変数(num)。
その時点での最大の距離を入れる変数(max)。→いらないかも
処理中のノードを入れる変数(p)。

最短路とその距離を入れる構造体を作る。→それを配列にしてキューを二つ作る。
　　・配列Aは決定した最短路を入れる。
　　・配列Bは候補である一時的な最短路を入れる。

辺の配列をコピーして新しく作る。仮に元の辺を辺A、新しい辺を辺Bとする。

最初にダイキストラ法を用いて普通に最短路を求めて、配列Aに格納する。

ループ(k番目まで見つけるまで){
処理中のノードを始点に設定する。

ループ(処理中のノードが始点から終点になるまで){
１、辺Bの初期化：辺Aに辺Bを代入。
２、配列Aの中で、処理中のノードから他のノードにつながる辺を見つけて、辺Bのなかの重みをINFにする。
３、その状態で、ダイキストラ法を用いて最短路を求めて、もしそれが配列Bに存在するものでなければ配列Bに格納。この時選択できる辺が全てINFであれば、探索しない。
４、処理中のノードを、現在探している第k最短路の第k-1最短路（つまり配列Aの最後の経路）を参照した時の次のノードに移動させる。
}

配列Bの中で最も距離が短い経路を選び、配列Aに移動。
}

最後に配列Aを返す。

了。




























double k_shortestPath(const Graph &g, int start, int end, int k) {
  const int n = g.size();//頂点の数？

  Graph h(n); // make reverse graph

//ここまではグラフのコピー？

  REP(u, n) FOR(e, g[u])
    h[e->dst].push_back(Edge(e->dst,e->src,e->weight));

  vector<Weight> d(n, INF); d[t] = 0; // make potential
  vector<int> p(n, -1);               // using backward dijkstra
  priority_queue<Edge> Q; Q.push(Edge(t, t, 0));
  while (!Q.empty()) {
    Edge e = Q.top(); Q.pop();
    if (p[e.dst] >= 0) continue;
    p[e.dst] = e.src;
    FOR(f, h[e.dst]) if (d[f->dst] > e.weight + f->weight) {
      d[f->dst] = e.weight + f->weight;
      Q.push(Edge(f->src, f->dst, e.weight + f->weight));
    }
  }
  int l = 0; // forward dijkstra-like method
  priority_queue<Edge> R; R.push(Edge(-1,s,0));
  while (!R.empty()) {
    Edge e = R.top(); R.pop();
    if (e.dst == t && ++l == k) return e.weight + d[s];
    FOR(f, g[e.dst])
      R.push(Edge(f->src, f->dst, e.weight+f->weight-d[f->src]+d[f->dst]));
  }
  return -1; // not found
}
