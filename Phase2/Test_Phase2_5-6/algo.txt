<k番目の最短距離、及び最短路を求める関数>
戻り値(最短路とその距離を入れる構造体の配列)
引数(全ての座標、辺、座標の数、始点と終点の座標、求める最短路の数)

必要な変数：
求められた最短路の数を格納する変数(num)。
その時点での最大の距離を入れる変数(max)。→いらないかも
処理中のノードを入れる変数(p)。

最短路とその距離を入れる構造体を作る。→それを配列にしてキューを二つ作る。
　　・配列Aは決定した最短路を入れる。
　　・配列Bは候補である一時的な最短路を入れる。

座標の配列をコピーして新たに作る。　ー＞どこかで初期化して使う。

辺の配列をコピーして新しく作る。仮に元の辺を辺A、新しい辺を辺Bとする。

最初にダイキストラ法を用いて普通に最短路を求めて、配列Aに格納する。

ループ(無限){
処理中のノードを始点と設定する。

ループ(処理中のノードが始点から終点になるまで){
１、辺Bの初期化：辺Bに辺Aを代入。
２、座標配列の初期化。
３、配列Aの中で、処理中のノードから他のノードにつながる辺を見つけて、辺Bのなかの重みをINFにする。
４、その状態で、ダイキストラ法を用いて最短路を求めて、もしそれが配列Bに存在するものでなければ配列Bに格納。この時選択できる辺が全てINFであれば、探索しない。B_num++.
５、処理中のノードを、現在探している第k最短路の第k-1最短路（つまり配列Aの最後の経路）を参照した時の次のノードに移動させる。
}

配列Bの中で最も距離が短い経路を選び、配列Aに移動。→　B_num--, A_num++
もし配列Aの最後の要素と同じ距離の経路しかなかった場合は、配列Aの最後の要素に配列Bのどれか(最後の要素)を上書き。B_num--.

if(A_num == k || B_num == 0) break;
}

最後に配列Aを出力。

了。
